# Python 异常与 `with` 自动清理总结

## 1. try / except / else / finally

### 语法示例
```python
try:
    result = x / y
except ZeroDivisionError:
    print("除数为0！")
else:
    print("结果是", result)
finally:
    print("执行finally")
```

### 执行逻辑
- `try`: 放可能出错的代码
- `except`: 捕获指定异常，处理错误
- `else`: **只有 try 成功**才执行，处理正常结果
- `finally`: **无论是否异常**，都会执行，用于清理资源

#### 逻辑关系图
```
开始
  │
  ▼
try 块
  │
  ├── 成功 → else 块 → finally 块 → 结束
  │
  └── 出错 → except 块 → finally 块 → 结束
```

### 执行示例
```python
x, y = 10, 2
try:
    result = x / y
except ZeroDivisionError:
    print("除数为0！")
else:
    print("结果是", result)
finally:
    print("执行finally")
```
输出：
```
结果是 5.0
执行finally
```

```python
x, y = 10, 0
try:
    result = x / y
except ZeroDivisionError:
    print("除数为0！")
else:
    print("结果是", result)
finally:
    print("执行finally")
```
输出：
```
除数为0！
执行finally
```

---

## 2. `with` 上下文管理器（自动清理）

### 语法示例
```python
with open("myfile.txt", "w") as f:
    f.write("Hello")
```
- 不需要手动调用 `f.close()`
- 即使 `write` 抛异常，文件也会被自动关闭

### 原理
- `with` 本质上封装了 `try/finally` 逻辑：
```python
f = open("myfile.txt", "w")
try:
    f.write("Hello")
finally:
    f.close()
```

### 对比逻辑流程图
#### 普通 try/finally:
```
开始
  │
  ▼
打开文件 f
  │
  ▼
try:
  写入内容 ← 可能抛异常
  │
  ├── 成功 → finally → 关闭文件 f → 结束
  └── 出错 → finally → 关闭文件 f → 异常抛出 → 结束
```

#### `with` 自动管理资源:
```
开始
  │
  ▼
with open(...) as f:
  │
  ▼
写入内容 ← 可能抛异常
  │
  ├── 成功 → 自动关闭文件 f → 结束
  └── 出错 → 自动关闭文件 f → 异常抛出 → 结束
```

### 优势
1. **异常安全**：保证资源释放，不用担心忘记 `close()`
2. **语法简洁**：比手动写 `try/finally` 更可读
3. **适用范围广**：文件、网络连接、锁、数据库连接等都可以用 `with`

### 记忆技巧
> `with` = 自动 try/finally，异常安全，语法简洁

---

### 总结
- `except` 与 `else` 互斥：try 成功走 else，失败走 except
- `finally` 无条件执行，常用于资源清理
- `with` 自动封装 try/finally，保证资源释放，提高代码可读性和安全性

