# Python 数据类 (dataclasses) 学习笔记

## 对话内容整理

**用户：**

``` python
9.11 dataclasses（数据类）
from dataclasses import dataclass

@dataclass
class Employee:
    name: str
    dept: str
    salary: int

john = Employee('John', 'IT', 1000)
print(john.dept, john.salary)  # IT 1000
```

用户：用于捆绑相关数据，类似 C 语言 struct。

用户：自动生成 **init**、**repr** 等方法。 ？？？？？？

**助手：** 你问到 **dataclasses（数据类）** 时提到的
`__init__`、`__repr__`，我来详细解释一下 👇

------------------------------------------------------------------------

## 1. 什么是 dataclass？

-   Python 的 `dataclasses` 模块是在 **Python 3.7** 引入的。\
-   它的作用是：让你快速定义
    **主要用于存储数据的类**，而不用自己去写一大堆样板方法。\
-   有点类似 **C语言里的 `struct`**，或者其他语言里的 **record / data
    class**。

------------------------------------------------------------------------

## 2. 自动生成的方法

当你在类前加上 `@dataclass` 装饰器时，Python
会**自动生成一些常用方法**，包括：

1.  **`__init__`**\
    自动生成初始化函数，把你声明的字段作为参数：

    ``` python
    john = Employee("John", "IT", 1000)
    # 相当于自动生成了:
    # def __init__(self, name, dept, salary):
    #     self.name = name
    #     self.dept = dept
    #     self.salary = salary
    ```

2.  **`__repr__`**\
    自动生成一个"漂亮的字符串表示"，方便调试和打印：

    ``` python
    print(john)
    # 输出：Employee(name='John', dept='IT', salary=1000)
    ```

3.  **`__eq__`**\
    自动生成比较两个实例是否相等的方法（字段逐一比较）：

    ``` python
    e1 = Employee("John", "IT", 1000)
    e2 = Employee("John", "IT", 1000)
    print(e1 == e2)  # True
    ```

4.  **其他可选方法**（取决于参数设置）

    -   `__lt__`、`__le__`、`__gt__`、`__ge__`：排序比较\
    -   `__hash__`：可让对象用作字典 key

------------------------------------------------------------------------

## 3. 你的例子拆解

``` python
from dataclasses import dataclass

@dataclass
class Employee:
    name: str
    dept: str
    salary: int

john = Employee('John', 'IT', 1000)
print(john.dept, john.salary)  # IT 1000
print(john)                    # Employee(name='John', dept='IT', salary=1000)
```

等价于手动写的类：

``` python
class Employee:
    def __init__(self, name: str, dept: str, salary: int):
        self.name = name
        self.dept = dept
        self.salary = salary

    def __repr__(self):
        return f"Employee(name={self.name!r}, dept={self.dept!r}, salary={self.salary!r})"

    def __eq__(self, other):
        if isinstance(other, Employee):
            return (self.name, self.dept, self.salary) == (other.name, other.dept, other.salary)
        return NotImplemented
```

------------------------------------------------------------------------

## 4. 常用进阶功能

-   默认值：

    ``` python
    @dataclass
    class Employee:
        name: str
        dept: str = "IT"   # 默认值
        salary: int = 5000
    ```

-   不可变对象（类似 tuple）：

    ``` python
    @dataclass(frozen=True)
    class Point:
        x: int
        y: int
    p = Point(1, 2)
    # p.x = 3  # ❌ 会报错，因为 frozen=True
    ```

-   排序：

    ``` python
    @dataclass(order=True)
    class Employee:
        salary: int
        name: str
    e1 = Employee(1000, "Alice")
    e2 = Employee(2000, "Bob")
    print(e1 < e2)  # True
    ```

------------------------------------------------------------------------

## 5. dataclass 参数对比表

  ---------------------------------------------------------------------------
  参数                    作用                    示例
  ----------------------- ----------------------- ---------------------------
  `init`                  是否自动生成 `__init__` `@dataclass(init=False)`

  `repr`                  是否自动生成 `__repr__` `@dataclass(repr=False)`

  `eq`                    是否生成 `__eq__` 方法  `@dataclass(eq=False)`

  `order`                 是否生成排序比较方法    `@dataclass(order=True)`

  `frozen`                是否不可变              `@dataclass(frozen=True)`

  `slots` (Python 3.10+)  是否使用 `__slots__`    `@dataclass(slots=True)`
                          节省内存                
  ---------------------------------------------------------------------------

------------------------------------------------------------------------

## 总结

-   `@dataclass` 让我们可以快速定义"数据存储类"，避免写重复代码。\
-   默认会生成
    `__init__`、`__repr__`、`__eq__`，还能通过参数控制更多功能。\
-   适合用来描述 **主要用于存储数据、逻辑不复杂的类**。
