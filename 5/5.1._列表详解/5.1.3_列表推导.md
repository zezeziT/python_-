# Python 学习笔记：列表推导式、生成器、map函数及元组列表基础

---

## 列表推导式（List Comprehension）

列表推导式是对序列或可迭代对象中的每个元素应用某种操作，创建新的列表；或者用满足条件的元素创建子序列。

```python
# 创建平方值的列表
squares = []
for x in range(10):
    squares.append(x**2)
print(squares)
# 注意，这段代码创建（或覆盖）变量 x，该变量在循环结束后仍然存在。
print(x)
python
复制代码
# 无副作用地计算平方列表
squares = [y**2 for y in range(10)]
print(squares)
# print(y) # 会报错，y is not defined；y是内部变量，用完后自动销毁
map() 函数
map() 会把一个函数应用到序列（或其他可迭代对象）中的每个元素上，返回一个“懒惰”的可迭代对象（生成器），需要用 list() 或循环取出结果。

python
复制代码
# ❗ 错误示范，map直接赋值未取值
squares = map(lambda x: x**2, range(10))
print(squares)  # <map object at 0x...>

# 正确示范
squares = list(map(lambda x: x**2, range(10)))
print(squares)
python
复制代码
# 自定义函数应用于 map()
def square(x):
    return x**2

nums = [1, 2, 3, 4]
result = map(square, nums)
print(list(result))

# 使用匿名函数(lambda)
result = map(lambda x: x**2, [1, 2, 3, 4])
print(list(result))
列表表达式与生成器表达式区别
列表推导式：用 [] 括起来，直接生成一个完整列表。

生成器表达式：用 () 括起来，生成一个生成器对象（lazy evaluation），节省内存，需用 list() 或 for 循环取值。

python
复制代码
s = [(x, y) for x in [1, 2, 3] for y in [3, 1, 4] if x != y]
print(s)  # 列表

g = ((x, y) for x in [1, 2, 3] for y in [3, 1, 4] if x != y)
print(g)          # <generator object ...>
print(list(g))    # 展开结果
print(list(g))    # [] 生成器用完了，空了
生成器只能用一次
生成器内部状态会随着遍历而改变，所有元素输出完毕后，生成器“耗尽”，再取不到数据。

python
复制代码
g = (x for x in range(3))
print(list(g))  # 输出 [0, 1, 2]
print(list(g))  # 输出 []，因为生成器已经空了
列表 vs 元组
列表 [] 是可变的，支持 .append()、修改元素等操作。

元组 () 是不可变的，创建后元素不能更改，也不支持 .append()。

python
复制代码
combs = []
for x in [1, 2, 3]:
    for y in [3, 1, 4]:
        if x != y:
            combs.append((x, y))
print(combs)

# combs = () 会报错，因为元组不支持 .append()
元组和列表的区别示例
python
复制代码
a = [(1, 2)]   # 列表，包含一个元组元素
b = [[1, 2]]   # 列表，包含一个列表元素

# a[0][0] = 100  # ❌ 报错，元组不可变
a[0] = (9, 9)    # ✅ 可以替换元组整体
b[0][0] = 100    # ✅ 列表可变

print(a, b)
总结
对象类型	是否可变	是否支持 append()	备注
列表 List []	可变	支持	用于需要频繁修改的数据结构
元组 Tuple ()	不可变	不支持	用于数据不可修改的情况
生成器 Generator	一次性迭代	不支持	节省内存，但只能遍历一次

备注
生成器表达式用圆括号包裹，不是元组哦！

元组是手动写的固定元素的组合，用圆括号表示，但生成器表达式和元组的语法不同。

列表推导式结果是列表，生成器表达式结果是生成器对象。